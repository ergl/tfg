\cleardoublepage
\chapter{Comparison Implementations Pseudocode}
\label{appendix:code}

\section{Serialisable}
\label{appendix:ser}

\begin{figure}[htb!]
\noindent\adjustbox{max width=\paperwidth}{\footnotesize
\begin{tabularx}{\linewidth}{|c|p{6cm}|X|}
  \hline
  \multicolumn{3}{|c|}{\textbf{Variables at a server $s_i$}} \\
  \hline
  \textbf{Name} & \textbf{Domain} & \textbf{Description} \\
  \hline
  $\lastprep$ & {\sf Integer} & The number of update transactions that tried to
  commit at the server.\\
  \hline
  $\CommitLog$
  & ${\sf Sequence}[\langle\transtype\ T,$ $\vctype\ V_c, \vctype\ V_a \rangle]$
  & Log of update transactions $T$ committed at the server, ordered by
  $V_c[i]$. Here $V_c$ is the commit vector of $T$ and $V_a$ is the aggregate
  vector of $T$: the join of the commit vectors of all transactions up to $T$ in
  $\CommitLog$.\\
  \hline
  $\LocalTime$ & $\vctype$ & The join of the commit vectors of all
  transactions in $\CommitLog$.\\
  \hline
  $\VersionLog$ & ${\sf Map}[\keytype,$ ${\sf
    Set}[\langle \valuetype\ \val, \vctype\ V_c \rangle]]$ & Database:
  a mapping from objects to lists of pairs of a value and the
  commit vector of the transaction that wrote it. The lists are ordered
  by the $i$-th component of the commit vectors.\\
  \hline
  $\CommitQueue$

  & Sequence$[\langle \transtype, {\sf State}, {\sf ReadSet}, {\sf WriteSet} \rangle]$ where ${\sf State}=\{\pending,\ready\}$

  & Queue containing information about update transactions trying to commit at the server. \\
  \hline\hline
  \multicolumn{3}{|c|}{\textbf{Context for a transaction $T$ at a client $c_i$}} \\
  \hline
  $T.\RS$ & ${\sf ReadSet}$ & Read-set of $T$. \\
  \hline
  $T.\WS$ & ${\sf WriteSet}$ & Write-set of $T$. \\
  \hline
  $T.\hasRead$ & ${\sf Vector}[{\sf Bool}]$ & Mapping showing whether $T$  has
  read a given partition.
\\
  \hline
  $T.\VCaggr$ & $\vctype$ & Snapshot vector: determines snapshots fixed at
  partitions $T$ has read from and possible causal dependencies at all other
  partitions.
  \\
  \hline
  $T.\VCdep$ & $\vctype$ & Dependency vector, representing all causal
  dependencies developed by $T$ during its execution.
\\
  \hline
\end{tabularx}
}
\caption{List of variables used in the Serialisability protocol, where ${\sf ReadSet} = {\sf Set}[\langle \keytype, {\sf Integer}\rangle]$ and ${\sf WriteSet} = {\sf Set}[\langle \keytype, \valuetype \rangle]$.}
\label{fig:ser-prot-ds-table}
\end{figure}

\begin{figure}[h]
\begin{algorithm}[H]
  \setcounter{AlgoLine}{0}
  % Start
  \SubAlgo{\Fun ${\tt start}()$}{
    \Return{$\KwSty{new}\ \transtype(
      \WS= \emptyset,
      \RS= \emptyset,
      \hasRead = \vec{\bot},
      \VCaggr = \vec{0},
      \VCdep = \vec{0})$
    };\label{alg:ser_start_tx}
  }

  \smallskip

  % Write
  \SubAlgo{\Fun ${\tt write}(T, x, v)$}{
    $\tx.\WS \leftarrow \left(\tx.\WS\ \backslash\ \{\langle x, \_ \rangle\}\right) \cup \{\langle x,v\rangle\}$\;
  }
\end{algorithm}
\caption{Initialisation of a transaction and update of an object \emph{x} at client $c_i$}
\end{figure}

\begin{figure}[h]
\begin{algorithm}[H]
  % Read
  \SubAlgo{\Fun ${\tt read}(T, x)$}{
    \If{$\langle x, v \rangle \in \tx.\WS$}{
      \Return{$v$}\;
    }

    $j \leftarrow \partitionof(x)$\;
    \Send{$\READREQUEST(x, T.\VCaggr, T.\hasRead)$} \KwTo $s_j$\;
    \Receive{$\READRETURN(m)$} \KwFrom $s_j$\;
    \uIf{$m = \abort$} {
      \Throw{$\abort$}\;
    }
    \ElseIf{$m = \langle v,\localVdep,\localVaggr \rangle$}{
      $\tx.\hasRead[j] \leftarrow \true$\;
      $\tx.\RS \leftarrow
        \left(\tx.\RS\ \backslash\ \{\langle x, \_ \rangle\}\right)
        \cup
        \{\langle x, \localVdep[j] \rangle\}$\;\label{alg:ser_rs_update}
      $\tx.\VCdep \leftarrow \max(\tx.\VCdep,\localVdep)$\;
      $\tx.\VCaggr \leftarrow \max(\tx.\VCaggr,\localVaggr)$\;
      \Return{$v$}\;
    }
  }

  \smallskip

  % ReadRequest
  \SubAlgo{\WhenReceived $\READREQUEST(x, \argVCaggr, \argHasRead)$ \KwFrom $c_j$}{
    \uIf{$\argHasRead[i]$} {
      $V \leftarrow \argVCaggr$\;
    }
    \Else{
      \Until{$\mrvc[i] \ge \argVCaggr[i]$}\;
      $r \leftarrow \max\{r \in \CommitLog \mid \forall j.\, \argHasRead[j] {\implies} \left(r.\Vaggr[j] \le \argVCaggr[j]\right)\}$\;
      \If{$r.\Vaggr[i] < \argVCaggr[i]$}{
        \Send{$\READRETURN(\abort)$} \KwTo $c_j$\;
        \Return\;
      }
      $V \leftarrow r.\Vaggr$\;
    }
    $\ver = \max\{\ver \in \VersionLog \mid ver.\Vcomm[i] \le V[i]\}$\;
    \Send{$\READRETURN(\ver.\val, \ver.\Vcomm,V)$} \KwTo $c_j$\;
  }
\end{algorithm}
\caption{Serialisable local and remote read of object \emph{x}}
\end{figure}

\begin{figure}[h]
\begin{algorithm}[H]
  % Commit
  \SubAlgo{\Fun ${\tt commit}(T)$\label{alg:commit_start}}{
    \ForAll{$\partj \in \partitions(\tx.\RS \cup \tx.\WS)$}{
      \Send{$\PREPARE(T, T.\RS, T.\WS, \VCdep)$} \KwTo $\partj$\;
    }

    $\commitVC \leftarrow \tx.\VCdep$\;
    $\outcome \leftarrow \commit$\;

    \ForAll{$\partj \in \partitions(\tx.\RS \cup \tx.\WS)$}{
      \Receive{$\VOTE(m)$} \KwFrom $\partj$\;
      \uIf{$m = \langle T, \abort \rangle$}{
        $\outcome \leftarrow \abort$\;
        \Break\;
      }
      \ElseIf{$m = \langle T, \commit, k \rangle$}{
        $\commitVC[j] \leftarrow k$\;
      }
    }

    \ForAll{$\partj \in \partitions(\tx.\RS \cup \tx.\WS)$}{
      \Send{$\DECIDE(\tx, \commitVC,\outcome)$} \KwTo $\partj$\;
    }

    \Return{$\outcome$}\;
  }

  \smallskip

  % Prepare
  \SubAlgo{\WhenReceived $\PREPARE(T, \localRS, \localWS, \localVdep)$ \KwFrom $c_j$}{
    \If{$
      (\exists T'.\ (\langle T', \pending, \localRS', \localWS' \rangle \in \cqueue$
      \begin{tabularx}{\linewidth}{l}
        \quad\quad\quad$\vee\ \langle T', \ready, \_, \_, \_ \rangle \in \cqueue)$\\
        \quad\quad\quad$\wedge\
        (\localWS' \cap \localRS \ne \emptyset
          \wedge \localRS' \cap \localWS \ne \emptyset)$\\
        $\vee \left(
          \exists x. \ \langle x, vsn \rangle \in \localRS
          \wedge (\VersionLog[x].\last.\Vcomm[i] > vsn)\right)$\\
      \end{tabularx}
    }{
      \Send{$\VOTE(t, \abort)$} \KwTo $c_j$\;
      \Return\;
    }

    $\lastprep \leftarrow \lastprep + 1$\;
    $\cqput(\tx, \pending, \localRS, \localWS)$\;
    \Send{$\VOTE(\tx, \commit, \lastprep)$} \KwTo $c_j$\;
  }

  \smallskip

  % Decide
  \SubAlgo{\WhenReceived $\DECIDE(T, \commitVC, \outcome)$ \KwFrom $c_j$}{
    \uIf{$\outcome = \commit$}{
      $\cqupdate(\langle \tx, \ready, \_, \_, \commitVC\rangle)$\;
    }
    \Else{
      $\cqremove(\tx)$\;
    }
  }

  \smallskip

  % Queue head
  \SubAlgo{\Upon $\langle T, \ready, \_, \localWS, \commitVC\rangle = \cqhead()$}{
    \ForAll{$\{\langle x , v \rangle \mid \langle x , v \rangle \in \localWS \wedge \partitionof(x) = i\}$} {
        $\vlapply(\langle x , v , \commitVC \rangle)$\;
    }

    $\mrvc \leftarrow \max(\mrvc,\commitVC)$\;
    $\cladd(T, \mrvc)$\;
    $\cqremove(T)$\;
  }
\end{algorithm}
\caption{Serialisable termination protocol at server $s_i$}
\end{figure}

\clearpage

\section{Read Committed}
\label{appendix:rc}

Read Committed (RC) is the weakest consistency criterion that satisfies the \emph{isolation} property required by ACID transactions. It forbids concurrent transactions from observing any data that has not been committed. It doesn't place any restriction on the ordering of transactions, and doesn't preclude write-write conflicts. Thus, transactions may be ordered in any way. Figure~\ref{fig:rc-prot-ds-table} shows a summary of the data structures involved in the protocol.

\begin{figure}[h]
\noindent\adjustbox{max width=\paperwidth}{\footnotesize
\begin{tabularx}{\linewidth}{|c|p{5.5cm}|X|}
  \hline
  \multicolumn{3}{|c|}{\textbf{Variables at a server $s_i$}} \\
  \hline
  \textbf{Name} & \textbf{Domain} & \textbf{Description} \\
  \hline
  $\CommitQueue$

  & Sequence$[\langle \transtype, {\sf State}, {\sf WriteSet} \rangle]$ where ${\sf State}=\{\pending,\ready\}$

  & Queue containing information about update transactions trying to commit at the server. \\
  \hline
  Database

  & Set$[\langle {\sf Object} ,{\sf Value}\rangle]$

  & Set representing the key-value store as a mapping from objects to values. \\
  \hline\hline
  \multicolumn{3}{|c|}{\textbf{Context for a transaction $T$ at a client $c_i$}} \\
  \hline
  $T.\WS$ & ${\sf WriteSet}$ & Write-set of $T$. \\
  \hline
\end{tabularx}
}
\caption{List of variables used in the Read Committed protocol, where ${\sf WriteSet} = {\sf Set}[\langle \keytype, \valuetype \rangle]$.}
\label{fig:rc-prot-ds-table}
\end{figure}

Since transactions only need to observe the last committed version of an object, it is sufficient to store only one version per key. In addition, transactions don't need to observe a consistent snapshot of the state of a partition, and therefore we can remove all data structures related to computing a snapshot. This is reflected in the execution of a transaction, as can be seen in Figure~\ref{fig:rc_tx_exection}. A server $s_i$ executing a remote read on behalf of a transaction $\tx$ simply fetches the currently available value of the requested object, and returns it to the client (line~\ref{alg:rc_db_get}).

A protocol satisfying Read Committed still needs to offer atomic visibility. To do so, our implementation uses two-phase commit, guaranteeing that a transaction commits at every partition (line~\ref{alg:rc_commit_start}). Servers that participate during the commit phase will always vote $\commit$ (line~\ref{alg:rc_send_vote}), since RC doesn't preclude write-write conflicts. After a successful commit phase, all partitions incorporate the transaction updates to its storage state (line~\ref{alg:rc_kv_apply}).

\begin{figure}[h]
\begin{algorithm}[H]
  \setcounter{AlgoLine}{0}
  %  Start
  \SubAlgo{\Fun ${\tt start}()$}{
    \Return{$\KwSty{new}\ \transtype(\WS= \emptyset)$};
  }

  \smallskip

  % Write
  \SubAlgo{\Fun ${\tt write}(T, x, v)$}{
    $\tx.\WS \leftarrow \left(\tx.\WS\ \backslash\ \{\langle x, \_ \rangle\}\right) \cup \{\langle x, v \rangle\}$\;
  }
\end{algorithm}
\caption{Transaction initialisation under Read Committed.}
\end{figure}

\begin{figure}[t]
\begin{algorithm}[H]

  % Read
  \SubAlgo{\Fun ${\tt read}(T, x)$}{
    \If{$\langle x, v \rangle \in \tx.\WS$}{
      \Return{$v$}\;
    }

    $j \leftarrow \partitionof(x)$\;
    \Send{$\READREQUEST(x)$} \KwTo $s_j$\;
    \Receive{$\READRETURN(v)$} \KwFrom $s_j$\;
    \Return{$v$}\;
  }

  \smallskip

  % ReadRequest
  \SubAlgo{\WhenReceived $\READREQUEST(x)$ \KwFrom $c_j$}{
    \Send{$\READRETURN(\kvget(x))$} \KwTo $c_j$\;\label{alg:rc_db_get}
  }

  \smallskip

    % Commit
  \SubAlgo{\Fun ${\tt commit}(T)$\label{alg:rc_commit_start}}{
    \If{$\ws = \emptyset$}{
      \Return{$\commit$}\;
    }

    \ForAll{$\partj \in \partitions(\tx.\WS)$}{
      \Send{$\PREPARE(T)$} \KwTo $\partj$\;
    }

    $\outcome \leftarrow \commit$\;
    \ForAll{$\partj \in \partitions(\tx.\WS)$}{
      \Receive{$\VOTE(m)$} \KwFrom $\partj$\;
      \If{$m = \langle T, \abort\rangle$}{
        $\outcome \leftarrow \abort$\;
        \Break\;
      }
    }

    \ForAll{$\partj \in \partitions(\tx.\WS)$}{
      \Send{$\DECIDE(\tx, \outcome)$} \KwTo $\partj$\;
    }

    \Return{$\outcome$}\;
  }

    % Prepare
  \SubAlgo{\WhenReceived $\PREPARE(T)$ \KwFrom $c_j$}{
    $\cqput(T, \pending, \WS)$\;
    \Send{$\VOTE(T, \commit)$} \KwTo $c_j$\;\label{alg:rc_send_vote}
  }

  % Decide
  \SubAlgo{\WhenReceived $\DECIDE(T, \outcome)$ \KwFrom $c_j$}{
    \uIf{$\outcome = \commit$}{
      $\cqupdate(\langle T, \ready, \_ \rangle)$\;
    }
    \Else{
      $\cqremove(T)$\;
    }
  }

  \smallskip

  % Queue head
  \SubAlgo{\Upon $\langle T, \ready, \localWS\rangle = \cqhead()$}{
    \ForAll{$\{\langle x, v\rangle \mid \langle x, v \rangle \in \localWS \wedge \partitionof(x) = i\}$}{
      $\kvapply(x, v)$\;\label{alg:rc_kv_apply}
    }
  $\cqremove(T)$\;
  }
\end{algorithm}
\caption{Read Committed execution protocol at server $s_i$}
\label{fig:rc_tx_exection}
\end{figure}
