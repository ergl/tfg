\cleardoublepage
\chapter{Related Work}
\label{chapter:related_work}

This chapter gives an overview of the previous work in the settings of transactional protocols, consistency, and application robustness. It also highlights the main differences between the contributions of this work and previous approaches.

% For robustness: Fekete for first establishing the concept, and Gotsman for showing how
% robustness can be applied to PSI

\paragraph{Application Robustness.} The notion of robustness as applied to databases was first investigated by Fekete et al.~\citep{fekete_ssi}, proposing a way to analyse if applications were robust against Snapshot Isolation (SI)~\citep{sql-critique}. The work of Fekete et al. has resulted in the proliferation of static analysis tools for detecting the presence of anomalies in applications~\citep{sudhir_static}, as well as several run-time techniques for ensuring serialisable transactions~\citep{ports_postgres}. More recently, Bernardi and Gotsman~\citep{concur_robustness} proposed several robustness criteria for a variety of consistency models, including Parallel Snapshot Isolation (PSI)~\citep{psi-intro}. The work on fastPSI builds on the robustness criteria of Parallel Snapshot Isolation and of Snapshot Isolation to build a hybrid protocol that allows programmers to selectively strengthen consistency guarantees for individual transactions.

% For entity groups: Megastore provided ACID transactions inside an entity group, and a relaxed
% consistency model across groups.

\paragraph{Entity Groups.} The concept of \emph{entity} was introduced by Helland~\citep{helland_entity} to refer to a self-contained data object, with application-defined boundaries, and uniquely identified by an entity key. In addition, Helland argued for the entity to be the largest \emph{scope of transactional serialisability}: transactions can only guarantee atomicity for objects held within the same entity, and are prevented from modifying objects across entities.

Later systems, such as Megastore~\citep{baker_megastore}, introduced the concept of \emph{entity groups}, disjoint aggregations of individual entities, allowing transactions to access distinct entities. Such systems offered strong consistency for transactions accessing entities within a group, while offering almost no consistency guarantees for transactions that accessed different entity groups. Such systems broadened the scope of transactional serialisability to encompass entire entity groups. In contrast, fastPSI provides PSI for all transactions, even those that access objects in multiple entity groups. At the same time, it further strengthens the consistency guarantees for transactions accessing only individual entity groups, by providing SI.

\paragraph{Strong Consistency Protocols.} Although there is a large variety of protocols providing strong consistency, this section focuses on those that provide similar guarantees to those in fastPSI, as well as others from which inspiration was drawn during the design of the fastPSI protocol.

% For PSI: Walter paper, used vector timestamps (similar to VCs), but fixed at the beginning of transactions, hence has base freshness. Partial replication, syncs in the background to achieve monotonic timestamps.

Walter, designed by Sovran et al.~\citep{psi-intro}, is a transactional replicated key-value store that offers Parallel Snapshot Isolation. To track causality relations between transactions, Walter uses vector timestamps with one entry per replica, compared to the version vectors used by fastPSI, with one entry per partition. In contrast with fastPSI, Walter can only offer snapshots with base freshness, as transactions fix a start timestamp at the beginning of their execution. As a result, the system may experience a higher rate of aborted transactions due to stale reads. Walter employs a single server per replica to assign monotonic timestamps and to manage transactions, which limits the overall scalability. In fastPSI, timestamps are assigned independently by each partition, and further allows any server to perform the role of transaction coordinator, which should result in better performance. Although Walter offers partial replication, the combination of replication and the choice of monotonic start timestamp leads the system to perform global communication in the background with all replicas.

% For NMSI: Ardekani, dependence vectors. First version has one entry per key. Big overhead, but snapshots are always as fresh as possible. Partitioned dependence vectors have less overhead, at the cost of only achieving forward freshness. (Genuine) Partial replication, atomic multicast.

Proposed by Saeida Ardekani et al.~\citep{ardekani_nmsi}, Jessy is a similar transactional key-value store, and the first system to provide Non-Monotonic Snapshot Isolation (NMSI). Unlike Walter, however, transactions in Jessy observe forward freshness in their snapshots, allowing greater scalability. To support consistent snapshots, Jessy uses a data structure called dependence vector, also similar to a version vector, with a number of entries either equal to the number of objects, or equal to the number of partitions. The former approach suffers from a big overhead, although it allows transactions to read versions of objects as fresh as possible. With one entry per partition, Jessy offers greater scalability, at the cost of introducing spurious conflicts between transactions. The fastPSI protocol follows a similar approach, using version vectors with one entry per partition. Like Walter, Jessy also supports partial replication. However, Jessy relies on atomic multicast primitives~\citep{guerraoui_multicast}, instead of the two-phase commit protocol used in Walter and fastPSI.

Another protocol that provides NMSI is Blotter, proposed by Moniz et al.~\citep{moniz_blotter}. In contrast with Jessy, Blotter supports full replication through the use of Paxos commit~\citep{gray_paxos_commit}. The design of Blotter shows how the properties of NMSI, like forward freshness, can be used to design protocols with full replication without loss of scalability.

Peluso et al.~\citep{peluso_gmu} proposed GMU, a transactional protocol that uses vector clocks to track causal dependencies. Much of the design of fastPSI is inspired by GMU, including its clock mechanism, as well as the approaches to build causally consistent snapshots. The consistency guarantees are different, however, as transactions in GMU satisfy the \emph{Extended Update Serialisability} (EUS)~\citep{hansdah_update_ser, adya_thesis} consistency model. EUS guarantees serialisability for update transactions, while read-only transactions can observe different commit orders for non-conflicting transactions, similar to the guarantees offered by the causally compatible snapshots of fastPSI. Even though GMU offers a stronger consistency model, it always commits read-only transactions, in contrast with the possibility of aborts under fastPSI when transactions cannot satisfy SI and PSI for the same snapshot.
