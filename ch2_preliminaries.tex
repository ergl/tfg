\cleardoublepage
\chapter{Preliminaries}

% \todo{

% ACID vs CAP. What's consistency? What's isolation? What is a consistency guarantee?

% Causal consistency. Vector clocks? Happens-before relationship

% What's a transaction. Follow \textsection 3 in GMU paper

% Explain the different levels of consistency (at least mention RC and SER, so we can talk about them during the evaluation) with the framework presented in Andrea/Alexey's CONCUR'15 paper (A Framework for Transactional Consistency Models with Atomic Visibility), using anomalies and abstract executions.

% Re: rationale. The reason for our prefix is so that we could build static analysis on top. (see the `Robustness against...' paper for this.)
% }

We begin with an introduction to the notation and basic concepts used throughout this thesis. We also review several \emph{strong} and \emph{weak} consistency criteria, based on the anomalies that are observable in each criterion. Finally, we discuss several protocols implementing some of these criteria, representing the previous work against which we compare our approach.

\section{Notation}

In this section, we define the elements we use throughout this chapter, such as transactions, histories, and relations. We follow the models used by Ardekani~\citep{ardekani_thesis}, Adya~\citep{adya_thesis} and Bernstein et al.~\citep{2pc-intro}.

\subsection{Objects and Transactions}

We consider a database storing \textbf{\em objects} $\Obj = \{x, y, \ldots\}$, which we assume to be integer-valued. Clients interact with the database via \textbf{\em transactions} $\Trans = \{\tx_i \mid i \in \mathbb{N}\}$, with $i$ being the \emph{transaction identifier} of $\tx$. A transaction is a totally ordered sequence of read or write operations, followed by a \emph{terminating} operation: either commit or abort. This order follows the order in which the client invoked such operations. Given an object $x$ and a transaction $\tx_i$, we call $x_i$ to the \textbf{\em version} $i$ of $x$ written by $\tx_i$. We denote by $w_i(x_i)$ when a transaction $\tx_i$ writes a version $i$ of $x$, and $r_i(x_i)$ when $\tx_i$ reads a version $i$ of $x$. Finally, we denote by $c_i$ when $\tx_i$ commits, and $a_i$ when it aborts. We assume an initial transaction $\tx_0$ writes the initial versions of every object in the database, and that for every transaction. Without loss of generality, we also assume that no transaction performs \emph{blind updates}, that is, for every write operation $w_i(x_i)$ performed by $\tx_i$, there's always a preceding read operation $r_i(x_i)$. We say that a transaction is \textbf{\em read-only} if its set of operations does not include writes, and \textbf{\em update} otherwise.

\subsection{Histories}

%% Talk of orderings here
% \subsection{Replication} Maybe not needed, left to the introduction, since we do not cover this


\section{Consistency Criteria}

In this section, we define what a consistency criterion is, along with several related concepts. We distinguish between \emph{strong} and \emph{weak} criteria, and give definitions for both classes. We give an overview of several criteria, and compare them in terms of their undesirable effects.

A consistency criterion is a \emph{safety} property that constrains how transactions interleave~\citep{ardekani_thesis}. Informally speaking, a safety property specifies that nothing bad happens~\citep{lamport_safety}. When talking of databases, this safety property is named isolation level (I in AC\underline{I}D), which specifies the degree to which concurrent transactions in a database are aware of each other~\citep{adya_thesis}. We will use the term consistency throughout this thesis, in accordance with Adya~\citep{adya_thesis}.

\subsection{Serialisability}
\subsection{Snapshot Isolation}
\subsection{Parallel Snapshot Isolation}
\subsection{Non-Monotonic Snapshot Isolation}
\subsection{Read Committed}

\section{Catalog of Protocols}
\subsection{Walter}
\subsection{Jessy}
% \subsection{GMU} Tentative, since we don't talk about US in previous section
