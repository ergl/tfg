\cleardoublepage
\chapter{The Protocol}
\label{protocol_chapter}

\newcommand{\Obj}{{\sf Obj}}
\newcommand{\partitions}{\ensuremath{\mathsf{partitions}}}
\newcommand{\TxVars}{\ensuremath{\mathsf{TxVars}}}
\newcommand{\Tvar}{\ensuremath{\mathsf{T}}}
\newcommand{\Svar}{\ensuremath{\mathsf{S}}}
\newcommand{\Clients}{\ensuremath{\mathsf{Clients}}}
\newcommand{\Partitions}{\ensuremath{\mathsf{Partitions}}}
\newcommand{\VCSet}{\ensuremath{\mathsf{VerVector}}}
\newcommand{\VCType}{\ensuremath{\mathit{V}}}
\newcommand{\WSType}{\ensuremath{\mathit{WS}}}

\newcommand{\MsgLabel}{\ensuremath{\mathsf{MessageLabels}}}
\newcommand{\Messages}{\ensuremath{\mathsf{Messages}}}

\newcommand{\localWS}{\ensuremath{\mathit{WS}}}
\newcommand{\partitionOf}{\ensuremath{\mathsf{partition}}}
\newcommand{\WS}{\ensuremath{\mathsf{WS}}}
\newcommand{\WriteSets}{\ensuremath{\mathsf{WriteSets}}}

\newcommand{\Tx}{\ensuremath{\mathsf{Tx}}}
\newcommand{\VCdep}{\ensuremath{\mathsf{Vdep}}}
\newcommand{\VCaggr}{\ensuremath{\mathsf{Vsnap}}}
\newcommand{\Vaggr}{\ensuremath{\mathsf{Vaggr}}}
\newcommand{\Value}{\ensuremath{\mathsf{Value}}}
\newcommand{\CommitTime}{\ensuremath{\mathsf{CommitTime}}}
\newcommand{\Vcomm}{\ensuremath{\mathsf{Vcomm}}}

\newcommand{\Versions}{\ensuremath{\mathsf{Versions}}}
\newcommand{\pending}{\text{\sc pending}}
\newcommand{\ready}{\text{\sc decided}}
\newcommand{\CQentries}{\ensuremath{\mathsf{CQentries}}}
\newcommand{\CLogs}{\ensuremath{\mathsf{CLogs}}}
\newcommand{\VLogs}{\ensuremath{\mathsf{Vlogs}}}
\newcommand{\PState}{\ensuremath{\mathsf{PState}}}

\newcommand{\CommitLog}{\ensuremath{\mathsf{CommitLog}}}
\newcommand{\CommitQueue}{\ensuremath{\mathsf{CommitQueue}}}
\newcommand{\VersionLog}{\ensuremath{\mathsf{VersionLog}}}
\newcommand{\LastTransactionProcessed}{\ensuremath{\mathsf{LastPrep}}}
\newcommand{\LocalTime}{\ensuremath{\mathsf{Vtotal}}}
\newcommand{\LocalEntry}{\ensuremath{\mathit{MVC}}}
\newcommand{\hasRead}{\ensuremath{\mathsf{HasRead}}}

\newcommand{\VCzero}{\ensuremath{\mathbf{0}_V}}
\newcommand{\dom}{\ensuremath{\mathsf{dom}}}

\newcommand{\Cevent}{\ensuremath{\mathsf{ConcEvents}}}
\newcommand{\actionOf}{\ensuremath{\mathsf{ActionOf}}}
\newcommand{\Act}{\ensuremath{\mathsf{Act}}}
\newcommand{\actstart}{\ensuremath{\mathsf{start}}}
\newcommand{\actwrite}{\ensuremath{\mathsf{write}}}
\newcommand{\actread}{\ensuremath{\mathsf{read}}}
\newcommand{\actreadreturn}{\ensuremath{\mathsf{read}\_\mathsf{return}}}
\newcommand{\actabort}{\ensuremath{\mathsf{abort}}}
\newcommand{\actreadrequest}{\ensuremath{\mathsf{read}\_\mathsf{request}}}
\newcommand{\actwritetolog}{\ensuremath{\mathsf{writeToVlog}}}
\newcommand{\actcommit}{\ensuremath{\mathsf{commit}}}
\newcommand{\actcommitreturn}{\ensuremath{\mathsf{commit}\_\mathsf{return}}}
\newcommand{\actprepare}{\ensuremath{\mathsf{prepare}}}
\newcommand{\actdecide}{\ensuremath{\mathsf{decide}}}
\newcommand{\actupdate}{\ensuremath{\mathsf{update}}}

\newcommand{\TxNew}{\ensuremath{\mathsf{TxNew}}}
\newcommand{\TxWrite}{\ensuremath{\mathsf{TxWrite}}}
\newcommand{\TxFirstRead}{\ensuremath{\mathsf{TxFirstRead}}}
\newcommand{\TxOtherRead}{\ensuremath{\mathsf{TxOtherRead}}}
\newcommand{\TxReadAbort}{\ensuremath{\mathsf{TxReadAbort}}}
\newcommand{\TxReadSuccessful}{\ensuremath{\mathsf{TxReadSuccess}}}
\newcommand{\TxReadRequestOld}{\ensuremath{\mathsf{TxOldReadRequest}}}
\newcommand{\TxReadRequestNew}{\ensuremath{\mathsf{TxNewReadRequest}}}
\newcommand{\TxReadRequestAbort}{\ensuremath{\mathsf{TxAbortReadRequest}}}
\newcommand{\TxReadOnlyCommit}{\ensuremath{\mathsf{TxReadOnlyCommit}}}
\newcommand{\TxStartCommit}{\ensuremath{\mathsf{TxStartCommit}}}
\newcommand{\TxEndCommit}{\ensuremath{\mathsf{TxEndCommit}}}
\newcommand{\TxWriteConflictConcurrent}{\ensuremath{\mathsf{TxWWConfConcurrent}}}
\newcommand{\TxWriteConflictCommitted}{\ensuremath{\mathsf{TxWWConfCommitted}}}
\newcommand{\TxNoWriteConflict}{\ensuremath{\mathsf{TxNoWWConf}}}
\newcommand{\TxDecideTrue}{\ensuremath{\mathsf{TxDecideTrue}}}
\newcommand{\TxDecideFalse}{\ensuremath{\mathsf{TXDecideFalse}}}
\newcommand{\TxUpdate}{\ensuremath{\mathsf{TxUpdate}}}

\newcommand{\msgreadrequest}{\ensuremath{\mathsf{READREQUEST}}}
\newcommand{\msgreadreturn}{\ensuremath{\mathsf{READRETURN}}}
\newcommand{\msgprepare}{\ensuremath{\mathsf{PREPARE}}}
\newcommand{\msgdecide}{\ensuremath{\mathsf{DECIDE}}}
\newcommand{\msgvote}{\ensuremath{\mathsf{VOTE}}}

\newcommand{\lastCompatibleVersion}{\ensuremath{\mathsf{lastCompatible}}}
\newcommand{\fixSnapshot}{\ensuremath{\mathsf{fixSnapshot}}}
\newcommand{\updateCommitVC}{\ensuremath{\mathsf{CommitVC}}}

\newcommand{\CommitVector}{\ensuremath{\mathsf{CommitVC}}}

\newcommand{\abort}{\text{\sc abort}}
\newcommand{\commit}{\text{\sc commit}}

\newcommand{\access}{\ensuremath{\mathsf{Access}}}

\newcommand{\TO}{\ensuremath{\mathsf{to}}}

\newcommand{\startEvent}{\ensuremath{\mathsf{startEvent}}}

\newcommand{\readmessages}{\ensuremath{\mathsf{readMessages}}}
\newcommand{\commitmessages}{\ensuremath{\mathsf{commitMessages}}}
\newcommand{\updatemessages}{\ensuremath{\mathsf{updateMessages}}}

\newcommand{\vlsubseteq}{\ensuremath{\sqsubseteq_{\mathsf{VL}}}}
\newcommand{\dvsubseteq}{\ensuremath{\sqsubseteq_{\mathsf{VC}}}}

\newcommand{\lastVC}{\ensuremath{\mathsf{lastVC}}}

\newcommand{\at}{\ensuremath{@}}

\newcommand{\localVaggr}{\mathit{Vaggr}}
\newcommand{\localVdep}{\mathit{Vdep}}
\newcommand{\argVCaggr}{\ensuremath{\mathit{Vsnap}}}
\newcommand{\argVCdep}{\ensuremath{\mathit{Vdep}}}
\newcommand{\argHasRead}{\mathit{HasRead}}
\newcommand{\argCommitVC}{\ensuremath{\mathit{commitVC}}}
\newcommand{\maxVC}{\ensuremath{\mathit{MaxVC}}}
\newcommand{\argMaxVC}{\ensuremath{\mathit{MaxVC}}}
\newcommand{\argVLog}{\ensuremath{\mathit{VersionLog}}}

\newcommand{\READREQUEST}{{\tt READREQUEST}}
\newcommand{\READRETURN}{{\tt READRETURN}}
\newcommand{\PREPARE}{{\tt PREPARE}}
\newcommand{\DECIDE}{{\tt DECIDE}}
\newcommand{\VOTE}{{\tt VOTE}}
\newcommand{\ABORT}{{\tt ABORT}}

\newcommand{\outcome}{\mathit{decision}}
\newcommand{\false}{\bottom}
\newcommand{\true}{\top}

\newcommand{\cqueue}{\CommitQueue}
\newcommand{\cqhead}{\CommitQueue.{\sf head}}
\newcommand{\cqupdate}{\CommitQueue.{\sf update}}
\newcommand{\cqremove}{\CommitQueue.{\sf remove}}
\newcommand{\cqput}{\CommitQueue.{\sf put}}

\newcommand{\cladd}{\CommitLog.{\sf add}}

\newcommand{\vlapply}{\VersionLog.{\sf add}}
\newcommand{\vllast}{\VersionLog.{\sf last}}
\newcommand{\last}{{\rm last}}
\newcommand{\ver}{\mathit{ver}}

\newcommand{\mrvc}{\LocalTime}

\newcommand{\lastprep}{\LastTransactionProcessed}

\newcommand{\parti}{\mathit{p_i}}
\newcommand{\partj}{\mathit{s_j}}

\newcommand{\transtype}{{\sf Tx}}
\newcommand{\keytype}{{\sf Object}}
\newcommand{\valuetype}{{\sf Value}}
\newcommand{\vctype}{{\sf VerVector}}

\newcommand{\val}{{\sf val}}

\newcommand{\tx}{\ensuremath{\mathit{T}}}

\newcommand{\commitVC}{\mathit{Vcomm}}

\newcommand{\localkey}{{\sf k}}
\newcommand{\localval}{{\sf v}}
\newcommand{\partitionof}{{\sf partition}}

\SetKwBlock{SubAlgoBlock}{}{end}
\newcommand{\SubAlgo}[2]{#1 \SubAlgoBlock{#2}}

\SetKw{Upon}{upon}
\SetKw{WhenReceived}{when received}
\SetKw{Send}{send}
\SetKw{Receive}{wait receive}
\SetKw{Until}{wait until}
\SetKw{KwFrom}{from}
\SetKw{KwTo}{to}
\SetKw{Throw}{throw}
\SetKw{Fun}{function}
\SetKw{Break}{break}
\SetKw{New}{new}

% Go over the different parts of the protocol, or at least the read request and prepare/decide.

% We should talk something about prefix order and read aborts here. Image of the executions that cause read aborts.

\todo{Protocol name?}
In this chapter, we describe how our protocol works. We first present how the system is modelled, followed by a description of the different data data structures that it encompasses. Next, we show how the protocol is implemented by going over the execution of a transaction, focusing in particular on the read and commit phases.

\section{System Model}

We consider an asynchronous, message-passing system consisting of a set of reliable processes connected by reliable channels. Fault-tolerance concerns are orthogonal to the problem we address. The processes are split into two sets; a set of \emph{servers} $\mathcal{S} = \{s_1, \dots, s_N\}$, and a set of \emph{clients} $\mathcal{C} = \{c_1, \dots, c_M\}$. The system manages a set of objects $\Obj$ split into $N$ partitions, each stored by a server process. We let $\partitionOf(x)$ be the index of the partition the object $x$ belongs to, so that it is managed by server $s_{\partitionOf(x)}$. Clients execute transactions by communicating with servers. Transactions can be \emph{interactive}, i.e., when a transaction starts, the client does not know which operations it will perform in advance. Clients refer to transactions by their identifier from a set $\transtype$.

\section{Server data structures}

The data structures maintained by the protocol at a process are summarised in Figure~\ref{fig:prot-ds-table}. Each server $s_i$ maintains a counter $\lastprep$ of the number of update transactions that initiated their commit phase at the server. When such a transaction commits at a server $s_i$, it will be assigned a \emph{sequence number} $k$ derived from this counter. All the update operations by the transaction at $s_i$ are identified by a pair $(s_i, k)$, which we call dot~\citep{carlos-causality}. We call the order of transactions imposed by their sequence numbers issued by $s_i$ the \emph{commit order} at $s_i$.

To track the happens-before relationship between transactions, we use \emph{version vectors}~\citep{version-vectors}. Such a vector consists of $n$ entries, each for each server, storing a non-negative integer. A version vector $V$ represents the set of dots $\{(s_i, k) \mid k \le V[i]\}$, which identify the writes by transactions whose sequence number at a server $s_i$ is no higher than $V[i]$. Version vectors are compared according to the following relation, showing when one vector covers more dots than another: $V_1 \sqsubseteq V_2 \iff \forall i.\ V_1[i] \le V_2[i]$. In addition, there exists a \emph{join} operation on vectors, taking their component-wise maximum. We we will denote this operation by $\max$ from now on. We also denote the set of all version vectors by $\VCSet$, and the vector with all entries set to $0$ by $\vec{0}$.

The protocol associates each committed transaction $\tx$ with a \emph{commit vector}---a version vector $V$ representing the dots that cover all the writes by $\tx$ as well as the writes of transactions preceding $\tx$ under happens-before. In particular, the entry $V[i]$ for a server $s_i$ where $\tx$ wrote an object stores the sequence number of $\tx$ issued by $s_i$. A server $s_i$ maintains a list of update transactions that committed at the server in a $\CommitLog$, storing triples $\langle T,V_c,V_a\rangle$. Here, $\tx$ is the identifier of a committed transaction, and $V_c$ is its commit vector. The $\CommitLog$ at $s_i$ is totally ordered according to the value $V_c[i]$, which follows the commit order at $s_i$. The last component of the triple, $V_a$, represents the join of the commit vectors of all the transactions up to $\tx$ in $\CommitLog$. This \emph{aggregate} vector is stored for efficiency---the server also caches the aggregate vector of the last committed transaction in a variable $\LocalTime$. Initially, the $\CommitLog$ contains a single dummy entry $\langle \_, \vec{0}, \vec{0} \rangle$.

A server $s_i$ maintains multiple versions of the objects it manages, stored in a mapping $\VersionLog$, which we call the \emph{database}. This log maps an object to a a list of \emph{versions}, pairs of a value and the commit vector of the transaction that wrote this value. The $\VersionLog$ is ordered by the $i$-th component of the commit vector of each version, which follows the commit order of transactions at $s_i$. We denote by $\VersionLog[x].\last$ the most recent entry in the list for the object $x$.

Finally, a server $s_i$ maintains an ordered queue $\CommitQueue$ of transactions trying to commit updates at the server. The queue has entries of two types. An entry $\langle \pending, T, \localWS \rangle$ means that $\tx$ is successfully prepared to commit at $s_i$, but the final decision on it is not yet known; $\localWS$ is the \emph{write-set} of the transaction, containing object-value pairs. An entry $\langle \ready, T, \localWS, V \rangle$ in the queue means that $\tx$ has been decided to commit with a commit vector $V$, but its writes have not yet been added to the $\VersionLog$. The order of transactions in $\CommitQueue$ follows the commit order at the server.

\section{Transaction Execution}
\todo{Maybe it's better to split the pseudocode and inline it with the text?}

A client executing a transaction $\tx$ maintains a transaction \emph{context} including several pieces of data, summarised in Figure~\ref{fig:prot-ds-table} and explained below. This context is initialised by the client when it starts a transaction (line~\ref{alg:start_tx_start}).

Since our protocol uses optimistic concurrency control, the execution of $\tx$ is speculative: clients read objects from servers and buffer writes locally. At the end of the execution, the decision whether to commit or abort a transaction is taken based on the existence of conflicts with concurrently executing transactions. When a transaction $\tx$ writes a value $v$ to an object $x$ (line~\ref{alg:write_start}), the client buffers this write in $\tx$'s \emph{write-set}, $\tx.\WS$, while discarding any previously written value of $x$.

When the transaction $\tx$ issues a read operation on an object $x$ (line~\ref{alg:read_start}), the client will first check $\tx.\WS$ (line~\ref{alg:read_ws_check}): if $\tx$ has already written to $x$, the value stored in the write-set is returned. Otherwise, and assuming that $j = \partitionOf(x)$, the client sends a $\msgreadrequest$ message to the server $s_j$ to fetch the value of the object (line~\ref{alg:read_send}).

When the transaction $\tx$ reads an object from a partition $j$ for the first time, the server $s_j$ fixes a \emph{snapshot} of versions from which it will serve all future reads by $\tx$. This snapshot is defined by an integer $k$: it will include the versions written by all the transactions that committed at the server with a sequence number up to $k$. The client keeps this information in the transaction context, by storing $k$ in the $j$-th entry of a \emph{snapshot vector} $\tx.\VCaggr$, and by marking the current partition as read in $\tx.\hasRead$, a Boolean mapping its $j$-th entry to $\top$ if $\tx$ read an object from $j$, and $\bot$ otherwise.


\input{ch4_pseudocode.tex}