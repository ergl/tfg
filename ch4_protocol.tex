\cleardoublepage
\chapter{The Protocol}
\label{protocol_chapter}

\newcommand{\Wconflict}{\text{\sc Conflict}\xspace}

\newcommand{\Obj}{{\sf Obj}}
\newcommand{\partitions}{\ensuremath{\mathsf{partitions}}}
\newcommand{\TxVars}{\ensuremath{\mathsf{TxVars}}}
\newcommand{\Tvar}{\ensuremath{\mathsf{T}}}
\newcommand{\Svar}{\ensuremath{\mathsf{S}}}
\newcommand{\Clients}{\ensuremath{\mathsf{Clients}}}
\newcommand{\Partitions}{\ensuremath{\mathsf{Partitions}}}
\newcommand{\VCSet}{\ensuremath{\mathsf{VerVector}}}
\newcommand{\VCType}{\ensuremath{\mathit{V}}}
\newcommand{\WSType}{\ensuremath{\mathit{WS}}}

\newcommand{\MsgLabel}{\ensuremath{\mathsf{MessageLabels}}}
\newcommand{\Messages}{\ensuremath{\mathsf{Messages}}}

\newcommand{\localWS}{\ensuremath{\mathit{WS}}}
\newcommand{\partitionOf}{\ensuremath{\mathsf{partition}}}
\newcommand{\WS}{\ensuremath{\mathsf{WS}}}
\newcommand{\WriteSets}{\ensuremath{\mathsf{WriteSets}}}

\newcommand{\Tx}{\ensuremath{\mathsf{Tx}}}
\newcommand{\VCdep}{\ensuremath{\mathsf{Vdep}}}
\newcommand{\VCaggr}{\ensuremath{\mathsf{Vsnap}}}
\newcommand{\Vaggr}{\ensuremath{\mathsf{Vaggr}}}
\newcommand{\Value}{\ensuremath{\mathsf{Value}}}
\newcommand{\CommitTime}{\ensuremath{\mathsf{CommitTime}}}
\newcommand{\Vcomm}{\ensuremath{\mathsf{Vcomm}}}

\newcommand{\Versions}{\ensuremath{\mathsf{Versions}}}
\newcommand{\pending}{\text{\sc pending}}
\newcommand{\ready}{\text{\sc decided}}
\newcommand{\CQentries}{\ensuremath{\mathsf{CQentries}}}
\newcommand{\CLogs}{\ensuremath{\mathsf{CLogs}}}
\newcommand{\VLogs}{\ensuremath{\mathsf{Vlogs}}}
\newcommand{\PState}{\ensuremath{\mathsf{PState}}}

\newcommand{\CommitLog}{\ensuremath{\mathsf{CommitLog}}}
\newcommand{\CommitQueue}{\ensuremath{\mathsf{CommitQueue}}}
\newcommand{\VersionLog}{\ensuremath{\mathsf{VersionLog}}}
\newcommand{\LastTransactionProcessed}{\ensuremath{\mathsf{LastPrep}}}
\newcommand{\LocalTime}{\ensuremath{\mathsf{Vtotal}}}
\newcommand{\LocalEntry}{\ensuremath{\mathit{MVC}}}
\newcommand{\hasRead}{\ensuremath{\mathsf{HasRead}}}

\newcommand{\VCzero}{\ensuremath{\mathbf{0}_V}}
\newcommand{\dom}{\ensuremath{\mathsf{dom}}}

\newcommand{\Cevent}{\ensuremath{\mathsf{ConcEvents}}}
\newcommand{\actionOf}{\ensuremath{\mathsf{ActionOf}}}
\newcommand{\Act}{\ensuremath{\mathsf{Act}}}
\newcommand{\actstart}{\ensuremath{\mathsf{start}}}
\newcommand{\actwrite}{\ensuremath{\mathsf{write}}}
\newcommand{\actread}{\ensuremath{\mathsf{read}}}
\newcommand{\actreadreturn}{\ensuremath{\mathsf{read}\_\mathsf{return}}}
\newcommand{\actabort}{\ensuremath{\mathsf{abort}}}
\newcommand{\actreadrequest}{\ensuremath{\mathsf{read}\_\mathsf{request}}}
\newcommand{\actwritetolog}{\ensuremath{\mathsf{writeToVlog}}}
\newcommand{\actcommit}{\ensuremath{\mathsf{commit}}}
\newcommand{\actcommitreturn}{\ensuremath{\mathsf{commit}\_\mathsf{return}}}
\newcommand{\actprepare}{\ensuremath{\mathsf{prepare}}}
\newcommand{\actdecide}{\ensuremath{\mathsf{decide}}}
\newcommand{\actupdate}{\ensuremath{\mathsf{update}}}

\newcommand{\TxNew}{\ensuremath{\mathsf{TxNew}}}
\newcommand{\TxWrite}{\ensuremath{\mathsf{TxWrite}}}
\newcommand{\TxFirstRead}{\ensuremath{\mathsf{TxFirstRead}}}
\newcommand{\TxOtherRead}{\ensuremath{\mathsf{TxOtherRead}}}
\newcommand{\TxReadAbort}{\ensuremath{\mathsf{TxReadAbort}}}
\newcommand{\TxReadSuccessful}{\ensuremath{\mathsf{TxReadSuccess}}}
\newcommand{\TxReadRequestOld}{\ensuremath{\mathsf{TxOldReadRequest}}}
\newcommand{\TxReadRequestNew}{\ensuremath{\mathsf{TxNewReadRequest}}}
\newcommand{\TxReadRequestAbort}{\ensuremath{\mathsf{TxAbortReadRequest}}}
\newcommand{\TxReadOnlyCommit}{\ensuremath{\mathsf{TxReadOnlyCommit}}}
\newcommand{\TxStartCommit}{\ensuremath{\mathsf{TxStartCommit}}}
\newcommand{\TxEndCommit}{\ensuremath{\mathsf{TxEndCommit}}}
\newcommand{\TxWriteConflictConcurrent}{\ensuremath{\mathsf{TxWWConfConcurrent}}}
\newcommand{\TxWriteConflictCommitted}{\ensuremath{\mathsf{TxWWConfCommitted}}}
\newcommand{\TxNoWriteConflict}{\ensuremath{\mathsf{TxNoWWConf}}}
\newcommand{\TxDecideTrue}{\ensuremath{\mathsf{TxDecideTrue}}}
\newcommand{\TxDecideFalse}{\ensuremath{\mathsf{TXDecideFalse}}}
\newcommand{\TxUpdate}{\ensuremath{\mathsf{TxUpdate}}}

\newcommand{\msgreadrequest}{\ensuremath{\mathsf{READREQUEST}}}
\newcommand{\msgreadreturn}{\ensuremath{\mathsf{READRETURN}}}
\newcommand{\msgprepare}{\ensuremath{\mathsf{PREPARE}}}
\newcommand{\msgdecide}{\ensuremath{\mathsf{DECIDE}}}
\newcommand{\msgvote}{\ensuremath{\mathsf{VOTE}}}

\newcommand{\lastCompatibleVersion}{\ensuremath{\mathsf{lastCompatible}}}
\newcommand{\fixSnapshot}{\ensuremath{\mathsf{fixSnapshot}}}
\newcommand{\updateCommitVC}{\ensuremath{\mathsf{CommitVC}}}

\newcommand{\CommitVector}{\ensuremath{\mathsf{CommitVC}}}

\newcommand{\abort}{\text{\sc abort}}
\newcommand{\commit}{\text{\sc commit}}

\newcommand{\access}{\ensuremath{\mathsf{Access}}}

\newcommand{\TO}{\ensuremath{\mathsf{to}}}

\newcommand{\startEvent}{\ensuremath{\mathsf{startEvent}}}

\newcommand{\readmessages}{\ensuremath{\mathsf{readMessages}}}
\newcommand{\commitmessages}{\ensuremath{\mathsf{commitMessages}}}
\newcommand{\updatemessages}{\ensuremath{\mathsf{updateMessages}}}

\newcommand{\vlsubseteq}{\ensuremath{\sqsubseteq_{\mathsf{VL}}}}
\newcommand{\dvsubseteq}{\ensuremath{\sqsubseteq_{\mathsf{VC}}}}

\newcommand{\lastVC}{\ensuremath{\mathsf{lastVC}}}

\newcommand{\at}{\ensuremath{@}}

\newcommand{\localVaggr}{\mathit{Vaggr}}
\newcommand{\localVdep}{\mathit{Vdep}}
\newcommand{\argVCaggr}{\ensuremath{\mathit{Vsnap}}}
\newcommand{\argVCdep}{\ensuremath{\mathit{Vdep}}}
\newcommand{\argHasRead}{\mathit{HasRead}}
\newcommand{\argCommitVC}{\ensuremath{\mathit{commitVC}}}
\newcommand{\maxVC}{\ensuremath{\mathit{MaxVC}}}
\newcommand{\argMaxVC}{\ensuremath{\mathit{MaxVC}}}
\newcommand{\argVLog}{\ensuremath{\mathit{VersionLog}}}

\newcommand{\READREQUEST}{{\tt READREQUEST}}
\newcommand{\READRETURN}{{\tt READRETURN}}
\newcommand{\PREPARE}{{\tt PREPARE}}
\newcommand{\DECIDE}{{\tt DECIDE}}
\newcommand{\VOTE}{{\tt VOTE}}
\newcommand{\ABORT}{{\tt ABORT}}

\newcommand{\outcome}{\mathit{decision}}
\newcommand{\false}{\bottom}
\newcommand{\true}{\top}

\newcommand{\cqueue}{\CommitQueue}
\newcommand{\cqhead}{\CommitQueue.{\sf head}}
\newcommand{\cqupdate}{\CommitQueue.{\sf update}}
\newcommand{\cqremove}{\CommitQueue.{\sf remove}}
\newcommand{\cqput}{\CommitQueue.{\sf put}}

\newcommand{\cladd}{\CommitLog.{\sf add}}

\newcommand{\vlapply}{\VersionLog.{\sf add}}
\newcommand{\vllast}{\VersionLog.{\sf last}}
\newcommand{\last}{{\rm last}}
\newcommand{\ver}{\mathit{ver}}

\newcommand{\mrvc}{\LocalTime}

\newcommand{\lastprep}{\LastTransactionProcessed}

\newcommand{\parti}{\mathit{p_i}}
\newcommand{\partj}{\mathit{s_j}}

\newcommand{\transtype}{{\sf Tx}}
\newcommand{\keytype}{{\sf Object}}
\newcommand{\valuetype}{{\sf Value}}
\newcommand{\vctype}{{\sf VerVector}}

\newcommand{\val}{{\sf val}}

\newcommand{\tx}{\ensuremath{\mathit{T}}}

\newcommand{\commitVC}{\mathit{Vcomm}}

\newcommand{\localkey}{{\sf k}}
\newcommand{\localval}{{\sf v}}
\newcommand{\partitionof}{{\sf partition}}

\SetKwBlock{SubAlgoBlock}{}{end}
\newcommand{\SubAlgo}[2]{#1 \SubAlgoBlock{#2}}

\SetKw{Upon}{upon}
\SetKw{WhenReceived}{when received}
\SetKw{Send}{send}
\SetKw{Receive}{wait receive}
\SetKw{Until}{wait until}
\SetKw{KwFrom}{from}
\SetKw{KwTo}{to}
\SetKw{Throw}{throw}
\SetKw{Fun}{function}
\SetKw{Break}{break}
\SetKw{New}{new}

% Go over the different parts of the protocol, or at least the read request and prepare/decide.

% We should talk something about prefix order and read aborts here. Image of the executions that cause read aborts.

\todo{Protocol name?}

In this chapter, we describe how our protocol works. We first present how the system is modelled, followed by a description of the different data data structures that it encompasses. Next, we show how the protocol is implemented by going over the execution of a transaction, focusing in particular on the read and commit phases.

\section{System Model}

We consider an asynchronous, message-passing system consisting of a set of reliable processes connected by reliable channels. Fault-tolerance concerns are orthogonal to the problem we address. The processes are split into two sets; a set of \emph{servers} $\mathcal{S} = \{s_1, \dots, s_N\}$, and a set of \emph{clients} $\mathcal{C} = \{c_1, \dots, c_M\}$. The system manages a set of objects $\Obj$ split into $N$ partitions, each stored by a server process. We let $\partitionOf(x)$ be the index of the partition the object $x$ belongs to, so that it is managed by server $s_{\partitionOf(x)}$. Clients execute transactions by communicating with servers. Transactions can be \emph{interactive}, i.e., when a transaction starts, the client does not know which operations it will perform in advance. Clients refer to transactions by their identifier from a set $\transtype$.

\section{Server data structures}

The data structures maintained by the protocol at a process are summarised in Figure~\ref{fig:prot-ds-table}. Each server $s_i$ maintains a counter $\lastprep$ of the number of update transactions that initiated their commit phase at the server. When such a transaction commits at a server $s_i$, it will be assigned a \emph{sequence number} $k$ derived from this counter. All the update operations by the transaction at $s_i$ are identified by a pair $(s_i, k)$, which we call dot~\citep{carlos-causality}. We call the order of transactions imposed by their sequence numbers issued by $s_i$ the \emph{commit order} at $s_i$.

To track the happens-before relationship between transactions, we use \emph{version vectors}~\citep{version-vectors}. Such a vector consists of $n$ entries, each for each server, storing a non-negative integer. A version vector $V$ represents the set of dots $\{(s_i, k) \mid k \le V[i]\}$, which identify the writes by transactions whose sequence number at a server $s_i$ is no higher than $V[i]$. Version vectors are compared according to the following relation, showing when one vector covers more dots than another: $V_1 \sqsubseteq V_2 \iff \forall i.\ V_1[i] \le V_2[i]$. In addition, there exists a \emph{join} operation on vectors, taking their component-wise maximum. We we will denote this operation by $\max$ from now on. We also denote the set of all version vectors by $\VCSet$, and the vector with all entries set to $0$ by $\vec{0}$.

The protocol associates each committed transaction $\tx$ with a \emph{commit vector}---a version vector $V$ representing the dots that cover all the writes by $\tx$ as well as the writes of transactions preceding $\tx$ under happens-before. In particular, the entry $V[i]$ for a server $s_i$ where $\tx$ wrote an object stores the sequence number of $\tx$ issued by $s_i$. A server $s_i$ maintains a list of update transactions that committed at the server in a $\CommitLog$, storing triples $\langle T,V_c,V_a\rangle$. Here, $\tx$ is the identifier of a committed transaction, and $V_c$ is its commit vector. The $\CommitLog$ at $s_i$ is totally ordered according to the value $V_c[i]$, which follows the commit order at $s_i$. The last component of the triple, $V_a$, represents the join of the commit vectors of all the transactions up to $\tx$ in $\CommitLog$. This \emph{aggregate} vector is stored for efficiency---the server also caches the aggregate vector of the last committed transaction in a variable $\LocalTime$. Initially, the $\CommitLog$ contains a single dummy entry $\langle \_, \vec{0}, \vec{0} \rangle$.

A server $s_i$ maintains multiple versions of the objects it manages, stored in a mapping $\VersionLog$, which we call the \emph{database}. This log maps an object to a a list of \emph{versions}, pairs of a value and the commit vector of the transaction that wrote this value. The $\VersionLog$ is ordered by the $i$-th component of the commit vector of each version, which follows the commit order of transactions at $s_i$. We denote by $\VersionLog[x].\last$ the most recent entry in the list for the object $x$.

Finally, a server $s_i$ maintains an ordered queue $\CommitQueue$ of transactions trying to commit updates at the server. The queue has entries of two types. An entry $\langle \pending, T, \localWS \rangle$ means that $\tx$ is successfully prepared to commit at $s_i$, but the final decision on it is not yet known; $\localWS$ is the \emph{write-set} of the transaction, containing object-value pairs. An entry $\langle \ready, T, \localWS, V \rangle$ in the queue means that $\tx$ has been decided to commit with a commit vector $V$, but its writes have not yet been added to the $\VersionLog$. The order of transactions in $\CommitQueue$ follows the commit order at the server.

\section{Transaction Execution}

\todo{Maybe it's better to split the pseudocode and inline it with the text?}

\todo{Maybe we should go over how snapshots are built, and explain how they can abort, before going over a sample execution.}

\subsection{Reading Objects and Building Consistent Snapshots}

A client executing a transaction $\tx$ maintains a transaction \emph{context} including several pieces of data, summarised in Figure~\ref{fig:prot-ds-table} and explained below. This context is initialised by the client when it starts a transaction (line~\ref{alg:start_tx_start}).

Since our protocol uses optimistic concurrency control, the execution of $\tx$ is speculative: clients read objects from servers and buffer writes locally. At the end of the execution, the decision whether to commit or abort a transaction is taken based on the existence of conflicts with concurrently executing transactions. When a transaction $\tx$ writes a value $v$ to an object $x$ (line~\ref{alg:write_start}), the client buffers this write in $\tx$'s \emph{write-set}, $\tx.\WS$, while discarding any previously written value of $x$.

When the transaction $\tx$ issues a read operation on an object $x$ (line~\ref{alg:read_start}), the client will first check $\tx.\WS$ (line~\ref{alg:read_ws_check}): if $\tx$ has already written to $x$, the value stored in the write-set is returned. Otherwise, and assuming that $j = \partitionOf(x)$, the client sends a $\READREQUEST$ message to the server $s_j$ to fetch the value of the object (line~\ref{alg:read_send}).

When the transaction $\tx$ reads an object from a partition $j$ for the first time, the server $s_j$ fixes a \emph{snapshot} of versions from which it will serve all future reads by $\tx$. This snapshot is defined by an integer $k$: it will include the versions written by all the transactions that committed at the server with a sequence number up to $k$. The client keeps this information in the transaction context, by storing $k$ in the $j$-th entry of a \emph{snapshot vector} $\tx.\VCaggr$, and by marking the current partition as read in $\tx.\hasRead$, a Boolean mapping its $j$-th entry to $\top$ if $\tx$ read an object from $j$, and $\bot$ otherwise. If $\tx.\hasRead[j]=\top$, then the vector $\tx.\VCaggr$ is equal to the join of the commit vectors of all transactions that at partition $j$ have a sequence number no higher than $\VCaggr[j]$, and vice versa.

\todo{This is the first time that causal dependency is mentioned.} Thus, the entries of the snapshot vector for partitions that $\tx$ has not yet read from delimit all the possible causal dependencies $\tx$ may develop at these partitions if it keeps reading objects from the snapshots it has already fixed.

Both $\tx.\VCaggr$ and $\tx.\hasRead$ are supplied by the client when issuing a read operation on object $x$, by using them as parameters to the $\READREQUEST$ message sent to the server $s_j$. When the server receives this message (line~\ref{alg:read_req_start}), it first checks, using the $\hasRead$ mapping, if the transaction has read from it before (line~\ref{alg:read_req_read_check}). In this case, the snapshot is determined by $\VCaggr[j]$, and the server returns the latest version $\mathit{ver}$ of the object $x$ written by a transaction in the snapshot, i.e., with a sequence number no higher than $\VCaggr[j]$ (line~\ref{alg:chose-version}). This version is determined by examining the $j$-th entry of the commit vectors in $\VersionLog$. The server then replies to the client with a $\READRETURN$ message containing the value of the chosen version and its associated version vector, as well as the unmodified snapshot vector provided by the client: since the server used a previously fixed snapshot, no updates to the vector are required.

We now consider the case when the client is reading from the server $s_j$ for the first time (line~\ref{alg:read_req_read_check_else}), in which case, we have to fix the snapshot for the transaction $\tx$ at this server. Choosing a suitable snapshot is complicated by the fact that we allow transactions to be interactive---that is, we do not know in advance which objects will read in the future. We hence fix the snapshot in such a way that \emph{any} later read from this snapshot will be causally \todo{cc} compatible with any reads (past or future) from the snapshots that $\tx$ has already read, as specified by $\hasRead$ and $\VCaggr$. To ensure this, the snapshot we select has to satisfy two requirements.

\todo{snip: insert two requirements. Example of read abort?}

Once the server fixes a new snapshot, it selects the most recent version of the object $x$, defined by $e.\Vaggr[j]$ (line~\ref{alg:chose-version}), to return to the client. The server replies with a $\READRETURN$ message, carrying a triple of the value of the object, its associated version vector, and the aggregate vector for $e.\Vaggr$, summarising the causal \todo{cc} dependencies of all the transactions in the snapshot. When the client receives the message (line~\ref{alg:read_msg_decomp}), it first sets the $j$-th entry of $\tx.\hasRead$ to $\top$, to indicate that $\tx$ has read an object at partition $j$, and joins the returned aggregate vector to $\tx.\VCaggr$. The client also joins the commit vector associated with the version read to a \emph{dependency vector} $\tx.\VCdep$, which represents all causal \todo{cc} dependencies developed by $\tx$ during its execution. This ensures that, upon reading a version of object $x$, $\tx$ will causally depend \todo{cc} on the transaction $\tx'$ that wrote that version of $x$, along with the causal dependencies of $\tx'$.

\todo{Verify that we mentioned read aborts in this section}

\subsection{Transaction Termination}

A client executing a transaction $\tx$ tries to commit it by calling a {\tt commit} function (line~\ref{alg:commit_start}). Read-only transactions are committed without any additional checks, since they already read a causally consistent snapshot (line~\ref{alg:commit_readonly_start}) \todo{define causally consistent snapshot}. To commit an update transaction $\tx$, we use a variant of the classical \emph{two-phase commit protocol (2PC)} \todo{cite 2PC?} among the processes that store the objects written by the transaction; the client executing $\tx$ servers as the 2PC coordinator.

In more detail, to commit a transaction $\tx$, the client first sends a $\PREPARE$ message to all servers storing the objects written by the transaction (line~\ref{alg:commit_send_loop}). The message contains $\tx$'s write-set and its dependency vector $\tx.\VCdep$. When a server $s_i$ receives this message (line~\ref{alg:prepare_start}), it \emph{validates} the transaction, deciding whether it can commit or abort due to conflicting concurrent transactions. The server then replies to the client with a \emph{vote} representing its decision. Based on the votes, the client determines the final decision on the transaction---the transaction commits if all votes are positive---and distributes the decision to the relevant servers.

We now describe how a server $s_i$ computes its vote on a transaction (line~\ref{alg:conflict_check}). The vote for a transaction $\tx$ ensures the following property, used to validate the \Wconflict axiom of PSI: \todo{Reference back to the model in previous chapter}

\begin{itemize}
    \item \emph{For any pair of distinct transactions $\tx_1$ and $\tx_2$ writing to an object $x$, if $\tx_1$ precedes $\tx_2$ in the commit order, then $\tx_2$ will se the version of $x$ at least as up-to-date as the one written by $\tx_1$.}
\end{itemize}

To ensure this property, the server $s_i$ first check whether, for the objects that $\tx$ wrote to, the versions that $\tx$ read are still the most up-to-date ones in the database of $s_i$ at the time of validation. The server then checks whether $\tx$ conflicts with any transactions present in $\CommitQueue$, which have started committing at the server, but whose writes have not been applied to the database yet---the server aborts $\tx$ if any transaction $\tx'$ in $\CommitQueue$ writes to the same object as $\tx$. The writes in $\CommitQueue$ may be applied to the database before the writes of $\tx$, so checking for conflicts with them ensures that $\tx$'s reads will still be up-to-date when $\tx$'s writes are applied to the database.

If the validation for transaction $\tx$ fails, the server sends a $\VOTE$ message with the vote \abort, which tells the client to abort the transaction. If the validation succeeds, the server generates a sequence number for the transaction by incrementing $\lastprep$ and sends to the client a $\VOTE$ message with this sequence number and a vote \commit. The server also adds an entry $\langle \pending, \tx, \tx.\WS \rangle$ to the $\CommitQueue$, to record the fact that it is trying to commit $\tx$ at the server (lines~\ref{alg:lastprep_incr}--\ref{alg:prepare_end}).

The client waits until it receives $\VOTE$ messages from all involved servers (line~\ref{alg:commit_recv_vote}). If all the servers voted \commit, the client constructs the final commit vector for $\tx$ by changing its dependency vector $\tx.\VCdep$, so that it covers not only $\tx$'s causal dependencies \todo{ref again}, but also all its writes. These writes are identified by the sequence numbers provided by the servers as part of their $\VOTE$ messages. Thus, the commit vector is defined by setting the entries in $\tx.\VCdep$ for partitions written by $\tx$ to these sequence numbers (line~\ref{alg:commit_assign_seqn}). The client then sends a $\DECIDE$ message to all the involved servers with the final decision on $\tx$ along with its commit vector (line~\ref{alg:commit_send_decide}).

Upon receiving the decision on a transaction $\tx$ (line~\ref{alg:decide_start}), a server updates the entry associated with $\tx$ in $\CommitQueue$, to change its status to $\ready$ and record its commit vector. If the transaction is aborted, the server removes $\tx$ from the queue.

Committed transactions are applied to the database in their order in $\CommitQueue$, i.e., the commit order. When a $\ready$ transaction $\tx$ gets to the head of the queue (line~\ref{alg:queue_start}), the server dequeues it and adds its writes to $\VersionLog$, tagged with its commit vector. The server then joins $\tx$'s commit vector to $\LocalTime$, and adds the transaction to $\CommitLog$, along with $\LocalTime$ as its aggregate vector.

\input{ch4_pseudocode.tex}
